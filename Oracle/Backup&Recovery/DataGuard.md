
DataGuard有三种模式：最大保护模式、最大可用模式、最大性能模式。
对于一个事务的提交，最大保护模式与最大可用模式要确保redo已传输至备库才返回。所以这两种方式对网络延迟的要求比较高，在网络条件比较差或者网络不稳定的情况下对主库性能有比较大的影响。
所以，在数据一致性要求不是很高的情况下建议采用最大性能模式，这也是使用最广泛的一种模式。这种方式在主库突然挂掉时会有3秒左右(可能更多)的数据丢失。

#### SYNC and ASYNC

■ The redo data generated by a transaction must have been received by every enabled destination that has the SYNC attribute before that transaction can commit.

■ The redo data generated by a transaction need not have been received at a destination that has the ASYNC attribute before that transaction can commit. This is the default behavior if neither SYNC or ASYNC is specified.
AFFIRM and NOAFFIRM

■ AFFIRM—specifies that a redo transport destination acknowledges received redo data after writing it to the standby redo log.

■ NOAFFIRM—specifies that a redo transport destination acknowledges received redo data before writing it to the standby redo log.

■ If neither the AFFIRM nor the NOAFFIRM attribute is specified, the default is AFFIRM when the SYNC attribute is specified and NOAFFIRM when the ASYNC attribute is specified.

■ Specification of the AFFIRM attribute without the SYNC attribute is deprecated and will not be supported in future releases.


Data Guard Protection Modes

#### Maximum Availability

```
This protection mode provides the highest level of data protection that is possible without compromising the availability of a primary database. Transactions do not commit until all redo data needed to recover those transactions has been written to the online redo log and to the standby redo log on at least one synchronized standby database. If the primary database cannot write its redo stream to at least one synchronized standby database, it operates as if it were in maximum performance mode to preserve primary database availability until it is again able to write its redo stream to a synchronized standby database. This mode ensures that no data loss will occur if the primary database fails, but only if a second fault does not prevent a complete set of redo data from being sent from the primary database to at least one standby database.
```

#### Maximum Performance

```
This protection mode provides the highest level of data protection that is possible without affecting the performance of a primary database. This is accomplished by allowing transactions to commit as soon as all redo data generated by those transactions has been written to the online log. Redo data is also written to one or more standby databases, but this is done asynchronously with respect to transaction commitment, so primary database performance is unaffected by delays in writing redo data to the standby database(s)

This is the default protection mode.
```

#### Maximum Protection

```
This protection mode ensures that no data loss will occur if the primary database fails. To provide this level of protection, the redo data needed to recover a transaction must be written to both the online redo log and to the standby redo log on at least one synchronized standby database before the transaction commits.

To ensure that data loss cannot occur, the primary database will shut down, rather than continue processing transactions, if it cannot write its redo stream to at least one synchronized standby database. Transactions on the primary are considered protected as soon as Data Guard has written the redo data to persistent storage in a standby redo log file. Once that is done, acknowledgment is quickly made back to the primary database so that it can proceed to the next transaction. This minimizes the impact of synchronous transport on primary database throughput and response time. To fully benefit from complete Data Guard validation at the standby database, be sure to operate in real-time apply mode so that redo changes are applied to the standby database as fast as they are received. Data Guard signals any corruptions that are detected so that immediate corrective action can be taken.

Because this data protection mode prioritizes data protection over primary database availability, Oracle recommends that a minimum of two standby databases be used to protect a primary database that runs in maximum protection mode to prevent a single standby database failure from causing the primary database to shut down
```

- 日志同步状态检查

```
在主库查看日志投递是否有错误：
col error for a10
col DESTINATION for a20
col DEST_NAME for a30
col SYNCHRONIZATION_STATUS for a20
set lines 400
SELECT dest_name,  
  status,  
  type,  
  database_mode,  
  recovery_mode,  
  error,  
  destination,  
  SYNCHRONIZATION_STATUS  
FROM V$ARCHIVE_DEST_STATUS;

在主库查看主备建的通道是否有错误：
set lines 300
col dest_name for a20
select INST_ID,DEST_NAME,status,error,to_char(APPLIED_SCN) from gv$archive_dest where TARGET='STANDBY';

恢复速度：
set lines 200
col type format a15
col ITEM format a26
col units format a15
col comments format a25
select * from v$recovery_progress;


在主备库查看standby相关进程的状态：
set linesize 200
col process for a10
col status for a15
col sequence# for 99999
select process,THREAD#,status,sequence#,BLOCK# from v$managed_standby;

备库查看传输延迟和应用延迟：
col value for a30
col datum_time for a30
col name for a30
select to_char(SYSDATE,'yyyymmdd hh24:mi:ss') CTIME,NAME,VALUE,DATUM_TIME from V$DATAGUARD_STATS WHERE NAME LIKE '%lag';


Set linesize 140
column Timestamp Format a20
column Facility  Format a24
column Severity  Format a13
column Message   Format a60 trunc

Select
   to_char(timestamp,'YYYY-MON-DD HH24:MI:SS') Timestamp,
   Facility,
   Severity,
   Message
From
   v$dataguard_status
Order by
   Timestamp;


select *
from (select TIMESTAMP,
            completion_time "ArchTime",
            SEQUENCE#,
            round((blocks * block_size) / (1024 * 1024), 1) "Size Meg",
            round((TIMESTAMP - lag(TIMESTAMP, 1, TIMESTAMP)
            OVER(order by TIMESTAMP)) * 24 * 60 * 60,1) "Diff(sec)",
            round((blocks * block_size) / 1024 /
                        decode(((TIMESTAMP - lag(TIMESTAMP, 1, TIMESTAMP)
                                OVER(order by TIMESTAMP)) * 24 * 60 * 60),
                               0,
                               1,
                               (TIMESTAMP - lag(TIMESTAMP, 1, TIMESTAMP)
                                OVER(order by TIMESTAMP)) * 24 * 60 * 60),
                        1) "KB/sec",
            round((blocks * block_size) / (1024 * 1024) /
                        decode(((TIMESTAMP - lag(TIMESTAMP, 1, TIMESTAMP)
                                OVER(order by TIMESTAMP)) * 24 * 60 * 60),
                               0,
                               1,
                               (TIMESTAMP - lag(TIMESTAMP, 1, TIMESTAMP)
                                OVER(order by TIMESTAMP)) * 24 * 60 * 60),
                        3) "MB/sec",
            round(((lead(TIMESTAMP, 1, TIMESTAMP) over(order by TIMESTAMP)) -
                        completion_time) * 24 * 60 * 60,
                        1) "Lag(sec)"
    from v$archived_log a, v$dataguard_status dgs
    where a.name = replace(dgs.MESSAGE, 'Media Recovery Log ', '')
        and dgs.FACILITY = 'Log Apply Services'
            order by TIMESTAMP desc)
where rownum < 10;
```

- 添加RAC备库：

```
srvctl add database -d ssb –o /opt/oracle/products/11.2.0 -p +datadg/ssb/spfilessb.ora
srvctl add instance -d ssb -i ssb1 -n exa505
srvctl add instance -d ssb -i ssb2 -n exa506
srvctl modify database –d ssb –r physical_standby
```

- 对standby上的redolog进行rename：

```
实例启动到mount状态
alter system set standby_file_management =manual;
ALTER DATABASE RECOVER MANAGED STANDBY DATABASE cancel;
alter database rename file '/data/data1/ORCLBAK/onlinelog/o1_mf_4_ch9vlf5g_.log' to '/data/data1/ORCLBAK/onlinelog/a.log';
alter database clear logfile group 4;
alter system set standby_file_management =auto;
clear后会在新的路径下产生redolog
```

- DataGuard相关参数

```
standby_file_management = AUTO
LOG_ARCHIVE_DEST_3='SERVICE=jsspdg LGWR ASYNC VALID_FOR=(ONLINE_LOGFILES,PRIMARY_ROLE) DB_UNIQUE_NAME=jsspdg'
FAL_SERVER=jsspdg
```

- STANDBY MANUALLY CREATE DATAFILE

```
alter database create datafile 'old filename' as 'new filename';
```


- 创建standby redo log

```
ALTER DATABASE ADD STANDBY LOGFILE GROUP 4 '+redodg' SIZE 1G;
SELECT GROUP#,THREAD#,SEQUENCE#,ARCHIVED,STATUS FROM V$STANDBY_LOG;
```


- 创建standby控制文件：

```
ALTER DATABASE CREATE STANDBY CONTROLFILE AS '/tmp/control01.ctl';
```

- 启动redo 应用

```
ALTER DATABASE RECOVER MANAGED STANDBY DATABASE using current logfile DISCONNECT FROM SESSION;
ALTER DATABASE RECOVER MANAGED STANDBY DATABASE DISCONNECT FROM SESSION;
alter database recover managed standby database parallel 20 using current logfile disconnect;
```

- 备库延时恢复：

```
ALTER DATABASE RECOVER MANAGED STANDBY DATABASE delay 1440 DISCONNECT FROM SESSION;
单位为分钟
```

- 查询保护模式

```
SELECT PROTECTION_MODE FROM V$DATABASE;
```

- 查询各个实例最近归档的日志序列号

```
SELECT MAX(SEQUENCE#), THREAD# FROM V$ARCHIVED_LOG
WHERE RESETLOGS_CHANGE# = (SELECT MAX(RESETLOGS_CHANGE#) FROM V$ARCHIVED_LOG)
GROUP BY THREAD#;
```

- 查找哪些归档文件没有被传输到备库，DEST_ID需要替换

```
SELECT LOCAL.THREAD#, LOCAL.SEQUENCE# FROM
(SELECT THREAD#, SEQUENCE# FROM V$ARCHIVED_LOG WHERE DEST_ID=1)
LOCAL WHERE
LOCAL.SEQUENCE# NOT IN
(SELECT SEQUENCE# FROM V$ARCHIVED_LOG WHERE DEST_ID=2 AND
THREAD# = LOCAL.THREAD#);
```

- 停止standby redo应用

```
ALTER DATABASE RECOVER MANAGED STANDBY DATABASE CANCEL;
```

- failover简要步骤

```
recover managed standby database finish;
startup mount force
alter database activate standby database;
startup force
```


- Switchover简要步骤

```
备库重启到mount状态
startup mount force
recover managed standby database disconnect;

关闭除实例一之外的所有实例：
shutdown immediate

查询switchover_status：
SQL> select switchover_status from v$database;
如果SWITCHOVER_STATUS的值为TO STANDBY 则:
SQL> ALTER DATABASE COMMIT TO SWITCHOVER TO PHYSICAL STANDBY;
如果SWITCHOVER_STATUS的值为SESSIONS ACTIVE 则:
SQL> ALTER DATABASE COMMIT TO SWITCHOVER TO PHYSICAL STANDBY WITH SESSION SHUTDOWN;
成功运行这个命令后，主数据库被修改为从数据库，备库收到END-OF-REDO标识

如果SWITCHOVER_STATUS的值为TO PRIMARY 则:
SQL> alter database recover managed standby database cancel;
SQL> ALTER DATABASE COMMIT TO SWITCHOVER TO PRIMARY;
如果SWITCHOVER_STATUS的值为SESSIONS ACTIVE 则:
SQL> ALTER DATABASE COMMIT TO SWITCHOVER TO PRIMARY WITH SESSION SHUTDOWN;
成功运行这个命令后，从数据库被修改为主数据库

新备库重启到read only并打开日志恢复
startup force;
ALTER DATABASE RECOVER  managed standby database using current logfile disconnect;  
```



- SNAPSHOT STANDBY相关操作

```
开启FRA:
参考flashback.md

recover managed standby database cancel;
alter database convert to snapshot standby;

sys@P1NDBCX>select DATABASE_ROLE from v$database;

DATABASE_ROLE
----------------
SNAPSHOT STANDBY

sys@P1NDBCX>alter database open;

Database altered.

激活的备库查询transfer lag:
select to_char(SYSDATE,'yyyymmdd hh24:mi:ss') CTIME,NAME,VALUE,DATUM_TIME from V$DATAGUARD_STATS WHERE NAME LIKE '%lag';
当前主库的归档同步正常，只不过不会进行恢复

sys@P1NDBCX>startup mount force;

sys@P1NDBCX>alter database convert to physical standby;

Database altered.

SNAPSHOT STANDBY生成的归档日志在其转换为physical standby时会自动清除。

sys@P1NDBCX>startup mount force;

sys@P1NDBCX>recover managed standby database using current logfile disconnect;
Media recovery complete.
```


- flush redo

```
在Oracle 11g里，Data Guard 切换多了一个新的功能：flush redo。
Flush 能把没有发送的redo 从主库传送到standby库。 只要主库能启动到mount状态，那么Flush就可以把没有发送的归档和current online redo 发送到备库。

Flush语法：
SQL> ALTER SYSTEM FLUSH REDO TO target_db_name;

这里的target_db_name 是我们在主库的db_unique_name 名称。 也就是在tnsnames.ora 文件配置的。 Flush 会将未发送的redo 从主库传到备库，并且等待redo 在standby 库上apply 之后返回成功。 所以只要Flush成功，那么Failover就没有数据丢失。
```
